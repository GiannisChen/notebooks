# 面试遇到的、可能遇到的问题和解答

### *进程与线程

- 基本概念：
  - 进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；
  - 线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。

- 区别：

  1.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。

  2.进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）

  3.进程是资源分配的最小单位，线程是CPU调度的最小单位；

  4.系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。

  5.通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预

  6.进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。

  7.进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉

  8.进程适应于多核、多机分布；线程适用于多核

### *进程通信

- 管道pipe
- socket套接字
- 系统IPC
  - 消息队列
  - 共享内存（最快的IPC）
- 命名管道FIFO（文件系统）

### 线程通信

- 公共资源区
- 事件同步
- 互斥量&信号量

### *死锁

- 死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件如下：
  - 互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；
  - 请求和保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源
  - 不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放
  - 环路等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链

- 解决死锁的方法即破坏上述四个条件之一，主要方法如下：
  - 破坏请求和保持条件：资源一次性分配，从而剥夺请求和保持条件
  - 可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件
  - 破坏循坏等待条件：资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件

### TCP可靠性保证

- 确认号，应答，超时重传
- 窗口控制，快速重传
- 拥塞控制
  - 慢开始
  - 拥塞避免
  - 快重传
  - 快恢复

### *TCP/IP模型

- 应用层
- 传输层
- 网络层
- 链路层

### *HTTP和HTTPS区别

- HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性

- HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥

- HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书

- HTTP协议端口是80，HTTPS协议端口是443

### HTTP返回码

- HTTP协议的响应报文由状态行、响应头部和响应包体组成，其响应状态码总体描述如下：
  - 1xx：指示信息--表示请求已接收，继续处理。
  - 2xx：成功--表示请求已被成功接收、理解、接受。
  - 3xx：重定向--要完成请求必须进行更进一步的操作。
  - 4xx：客户端错误--请求有语法错误或请求无法实现。
  - 5xx：服务器端错误--服务器未能实现合法的请求。

- 常见状态代码、状态描述的详细说明如下。
  - 200 OK：客户端请求成功。
  - 206 partial content服务器已经正确处理部分GET请求，实现断点续传或同时分片下载，该请求必须包含Range请求头来指示客户端期望得到的范围
  - 300 multiple choices（可选重定向）:被请求的资源有一系列可供选择的反馈信息，由浏览器/用户自行选择其中一个。
  - 301 moved permanently（永久重定向）：该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。
  - 302 move temporarily(临时重定向)：请求的资源现在临时从不同的URI中获得，
  - 304：not modified :如果客户端发送一个待条件的GET请求并且该请求以经被允许，而文档内容未被改变，则返回304,该响应不包含包体（即可直接使用缓存）。
  - 403 Forbidden：服务器收到请求，但是拒绝提供服务。
  - 404 not Found：请求资源不存在，举个例子：输入了错误的URL。

### OSI七层模型和TCP/IP四层模型和有关协议

- OSI七层模型及其包含的协议如下:
  - 物理层: 通过媒介传输比特,确定机械及电气规范,传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45
  - 数据链路层: 将比特组装成帧和点到点的传递,传输单位为帧,主要包括的协议为MAC VLAN PPP
  - 网络层：负责数据包从源到宿的传递和网际互连，传输单位为包,主要包括的协议为IP ARP ICMP
  - 传输层：提供端到端的可靠报文传递和错误恢复，传输单位为报文,主要包括的协议为TCP UDP
  - 会话层：建立、管理和终止会话，传输单位为SPDU，主要包括的协议为RPC NFS
  - 表示层: 对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII
  - 应用层: 允许访问OSI环境的手段,传输单位为APDU，主要包括的协议为FTP HTTP DNS

  ![img](https://www.javanav.com/aimgs/image__20191015135018.png)
  
- TCP/IP 4层模型包括：
  - 网络接口层：MAC VLAN
  - 网络层:IP ARP ICMP
  - 传输层:TCP UDP
  - 应用层:HTTP DNS SMTP

### *UDP和TCP端口复用问题

- 协议号和端口号构成唯一识别（TCP-6，UDP-17）
- 传输层以下不管TCP和UDP
- DNS在port 53上复用

### *UDP和TCP区别

-  连接
  - TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。
  - UDP无连接。

- 服务对象
  - TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；
  - UDP支持一对一，一对多，多对一，多对多的交互通信。

- 可靠性
  - TCP是可靠交付：无差错，不丢失，不重复，按序到达。
  - UDP是尽最大努力交付，不保证可靠交付。

- 拥塞控制，流量控制
  - TCP有拥塞控制和流量控制保证数据传输的安全性。
  - UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。

- 报文长度
  - TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。
  - UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。

- 首部开销
  - TCP首部开销大，首部20个字节。
  - UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）

- TCP和UDP适用场景
  - 从特点上我们已经知道，TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。
  - 若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。

### *GET和POST区别

- 概括
  - 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
  - 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）

- 区别：
  - get参数通过url传递，post放在request body中。
  - get请求在url中传递的参数是有长度限制的，而post没有。
  - get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。
  - get请求只能进行url编码，而post支持多种编码方式。
  - get请求会浏览器主动cache，而post支持多种编码方式。
  - get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。
  - GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。
  - GET产生一个TCP数据包；POST产生两个TCP数据包。

### SOCKET with UDP/TCP

![image-20200819162227769](C:\Users\GiannisChen\AppData\Roaming\Typora\typora-user-images\image-20200819162227769.png)

![image-20200819162241228](C:\Users\GiannisChen\AppData\Roaming\Typora\typora-user-images\image-20200819162241228.png)

### *数据库事务一致性

事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。

事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。

- 原子性（Atomicity）

  原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，[删删删]因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

- 一致性（Consistency）

  一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

  拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

- 隔离性（Isolation）

  隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

  即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

  多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。

  **不同的隔离级别**：

  - Read Uncommitted（读取未提交[添加中文释义]内容）：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。
  - Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。
  - Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。
  - Serialization（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。

- 持久性（Durability）

  持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

  例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。

### *范式

- 1NF：属性不可分
- 2NF：消除多值依赖
- 3NF：消除传递依赖

### *数组和链表

- 连续存放 vs 指针链接
- 增删难 vs 增删简单
- 随机访问 vs 顺序访问

### 设计模式

- 单例模式（单类单实例，C++局部静态变量）
- 工厂模式（代码复用）
- 观察者模式
- 装饰器模式

### OOP的设计模式的五项原则

- 单一职责原则

单一职责有2个含义，一个是避免相同的职责分散到不同的类中，另一个是避免一个类承担太多职责。减少类的耦合，提高类的复用性。

- 接口隔离原则

表明客户端不应该被强迫实现一些他们不会使用的接口，应该把胖接口中额方法分组，然后用多个接口代替它，每个接口服务于一个子模块。简单说，就是使用多个专门的接口比使用单个接口好很多。

该原则观点如下：
1）一个类对另外一个类的依赖性应当是建立在最小的接口上

2）客户端程序不应该依赖它不需要的接口方法。

- 开放-封闭原则

open模块的行为必须是开放的、支持扩展的，而不是僵化的。

closed在对模块的功能进行扩展时，不应该影响或大规模影响已有的程序模块。一句话概括：一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。

核心思想就是对抽象编程，而不对具体编程。

- 替换原则

子类型必须能够替换掉他们的父类型、并出现在父类能够出现的任何地方。

主要针对继承的设计原则

1）父类的方法都要在子类中实现或者重写，并且派生类只实现其抽象类中生命的方法，而不应当给出多余的,方法定义或实现。

2）在客户端程序中只应该使用父类对象而不应当直接使用子类对象，这样可以实现运行期间绑定。

- 依赖倒置原则

上层模块不应该依赖于下层模块，他们共同依赖于一个抽象，即：父类不能依赖子类，他们都要依赖抽象类。

抽象不能依赖于具体，具体应该要依赖于抽象。

### *i++和++i的线程安全

- 过程：
  - i读入寄存器
  - 寄存器累加
  - 写入内存
- 特点：非原子操作，当读入时可能会出现读旧值而写的时候会出现写不一致，无法复现

### *多态和虚函数

多态的实现主要分为静态多态和动态多态。

- 静态多态主要是重载，在编译的时候就已经确定；
- 动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。
- 虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。

### *虚函数和纯虚函数

- 虚函数
  - 可以有且必须有相应的定义；
  - 一般由子类实现并调用子类接口，动态绑定；
  - 析构函数是虚函数，会调用基类的析构函数；
  - 构造函数不能是虚函数：
    - 对象还没有实例化，无法在创建新对象过程中，生成对应的虚指针访问父类再定位到子类的方法中；
    - 空间大小不确定，尚未生成虚指针；
- 纯虚函数
  - 不能被实例化，是抽象类；
  - 用于规范化代码和明确需要生成的函数，避免误调用；

---

### JVM和JRE

- **JVM**

  Java虚拟机，它是整个Java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。

- **JRE**

  是指java运行环境。光有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。在JDK的安装目录里你可以找到jre目录，里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。

- **JDK**

  指的是Java的工具包。
  JDK包含JRE，而JRE包含JVM。

---

### Java反射机制

![img](https://img-blog.csdn.net/20170513133210763)

- 隐式反射
- 显式反射

---

### final关键字

**final** **语义是不可改变的**。

- 被 final 修饰的类，不能够被继承。
- 被 final 修饰的成员变量必须要初始化，赋初值后不能再重新赋值(可以调用对象方法修改属性值)。对基本类型来说是其值不可变；对引用变量来说其引用不可变，即不能再指向其他的对象。
- 被 final 修饰的方法代表不能重写。