## 华为OD笔试 2023-11-23场

> 一道NOI省选，你真看得起我，华子ヾ(≧へ≦)〃



### 第一题

现有 $n$ 个任务需要在 $t$ 时间内处理完成，同一时间只能处理一个任务，处理每个任务所需要的时间固定为1。每个任务都有最晚处理时间限制和积分值，在最晚处理时间点之前处理完成任务才可获得对应的积分奖励。
可用于处理任务的时间有限，请问在有限的时间内，可获得的最多积分？

- $1 \le n \le 10^2$，$1 \le t \le 10^2$



#### 思路

这道题看似比较复杂，但是每个任务只限定了结束时间而没有限定开始时间，且每个任务的耗时都为单位时间，那么我们首选是贪心。

1. 首先来一个**错误的思路**，能否正着贪心呢？我们来维护一个队列，初始时所有任务都在这个队列里，这个队列是个优先队列：

   - 当到达一个时间点时，取出中间最大的积分值；

   - 当中间有任务超时，直接剔除；

   这个思路看着很美好是吧，但是有个小问题：你怎么保证每次取出的值一定是全局最优呢？显然有反例：

   ```
   2 1
   2 3
   5 6
   5 7
   5 8
   ```

   按照我们上面的思路：

   - 当时间为0时，队列里是：8-7-6-3-1，我们取8；
   - 当时间为1时，队列里是：7-6-3-1，我们取7；
   - 当时间为2时，队列里是：6-3-1，我们取6；
   - 当时间为3时，队列里是：3-1，我们想取3，但是发现3对应的超时时间为2，过期了；

   **显然这个时候就产生了问题，局部最优并非全局最优！**

2. 正着贪心不太行，因为会出现截至时间晚的“抢了”截至时间早的。那么，自然而然想到倒过来贪心能不能卡掉这个问题呢？我们还是维护一个优先队列，这时候我们从 $t$ 开始向前遍历：

   - 当 $t$ 等于某一个截至时间时，将该截止时间对应的所有积分加入队列，**这是因为我们每次计算的是到该时间 $T$ 时，$[T-1, T]$ 这个时间区间内运行的任务**；
   - 当有限队列中有值时，取出积分最大的一个；

   还是上面的例子，我们假设 $t==7$，即时间为7：

   - 当时间为7和6时，队列为空；
   - 当时间为5时，加入，队列为8-7-6，取出一个8；
   - 当时间为4时，队列为7-6，取出一个7；
   - 当时间为3时，队列为6，取出一个6；
   - 当时间为2时，加入，队列为3-1，取出一个3；
   - 当时间为1时，队列为1，取出一个1；

   这样就很正常了。

其余则是一些外围的工作：

1. 首先我们需要一个**大小为 $t+1$ 的数组**作为map，元素也是一个数组，存截止时间对应的**积分们**；
2. 然后维护一个**优先队列**，每次取出**最大值**；

**需要注意的是**：

1. 当遍历时间戳等于某个截止时间时，**先把**积分们放入优先队列，再取出最大的积分值；



#### 代码

```go
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        // 读数据
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int t = sc.nextInt();
        
        // 二维数组构造map
       	// 首先初始化二维数组
        List[] list = new ArrayList[t + 1];
        for (int i = 0; i < t + 1; i++) {
            list[i] = new ArrayList();
        }
		// 读<截止时间, 积分>的数对
        for (int i = 0; i < n; i++) {
            int endTime = sc.nextInt();
            int value = sc.nextInt();
            // 维护 截止时间 -> 积分s 的一对多关系 
            list[Math.min(endTime, t)].add(value);
        }

        int ans = 0;
        List<Integer> waitList = new ArrayList<>();
        // 倒着贪心！这一步很重要，必须倒着！
        for (int i = t; i > 0; i--) {
            // 我们考虑时间戳t时，考虑的是[t-1,t]这个区间的任务执行
            waitList.addAll(list[i]);
            // 快速失败思想，取出优先队列中最大的一个，也可以排序，可以优化的点！
            if (!waitList.isEmpty()) {
                waitList.sort(Comparator.comparingInt(o -> o));
                // 取出最大值
                ans += waitList.remove(waitList.size() - 1);
            }
        }
        System.out.println(ans);
    }
}
```



#### 复杂度

- 时间复杂度：$O(t \times (n + n\log n))$（时间遍历 $t$ ；**`addAll`最差 $O(n)$，**当然默认没有优化；优先队列 $\log n$ ；**我们用的排序 $n\log n$** ）
- 空间复杂度：$O(\max(t,n))$（字典大小为 $t$ ；优先队列大小为 $n$ ）
