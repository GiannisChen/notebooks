# 第一章：图



**图**（Graph）作为《从零开始的LeetCode筑基速成指北》的第一章，是考虑到其他问题非常抽象，不如直接那比较具体的图（Graph）作为起点，一来是比较具体，能画张图就表达出原理，二来机考笔试中确实频繁出现，占比较大。

《图》这一章中，我们将主要涉及**树**（一种特殊的图，连通，无环）和**图**，以及依赖这两种数据结构常见的题型和算法。那么，我们开始吧。



## 图（Graph）

图是一种很常见的数据结构，常见于以**迷宫**，**岛屿**，**网络**为关键词的题目中，这些题目中往往会出现一个构建好或者等待构建的网状结构，那就是图。（图片来自：[1334. 阈值距离内邻居最少的城市](https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/)）

![img](images/find_the_city_01.png)

这张图上节点往往会有编号，边上会有权值。有时候，节点上也会有一定的权值用于不同规则的计算，这个我们放到后面讲。

那么，我们现在对图有了一定直观的映像，接下来，我们将从**图的存储**到**具体算法**对图和图的例题做讲解。



### 图的存储

我们一般采用两种方式存储图：**邻接矩阵**和**邻接表**。



#### 邻接矩阵

这应该是我们最为熟悉的存图的方式了，我们开一个二维数组`adj`表示图本身，二维数组的下标`i`，`j`分别表示编号为`i`和`j`的节点，`adj[i][j]`表示节点`i`，`j`是否有一条边（通常用`MAX_INT`或者`-1`表示不连通，`1`或者某个正数表示两个节点间的距离，`0`表示`i==j`）。那么我们上边的图就能表示为：

```shell
 0  3 -1 -1
 3  0  1  4
-1  1  0  1
-1  4  1  0
```

我们分析一下这个建图方式的复杂度：

- 查询是否存在一节点到另一节点的边：$O(1)$
- 遍历一个节点的下一个相连的节点：$O(n)$
- 遍历整张图：$O(n^2)$
- 空间复杂度：$O(n^2)$

显然在某些时候，**邻接矩阵**不是万能的，当$n$很大的时候，空间复杂度过高将是邻接矩阵的致命问题。同样，《数据结构》这门课上也告诉我们，邻接矩阵存**稀疏图**会造成相当多的浪费，所以这只适合部分题型，例如：有障碍的迷宫，由于迷宫中存在通路和不能走的墙体，甚至有些题目中还有陷阱等，这时候一般会用邻接矩阵，此时$n$一般不会太大。（图片来自：[1926. 迷宫中离入口最近的出口](https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/)）

![img](images/nearest1-grid.jpg)

#### 邻接矩阵建图

邻接矩阵建图就是遍历，此处还是提供边相关的二维矩阵`edges`，`edges[i]==int[]{u, v}`其中`u`，`v`为不同节点：

```c
for (int i=0; i<n; i++) {
    int u = edges[i][0];
    int v = edges[i][1];
    adj[u][v] = 1;
    adj[v][u] = 1;
}
```



#### 邻接表

**邻接表**常用于机考的图有关的题目中，包括**树**中也会使用邻接表来表示。邻接表也是一个**二维数组**`adj`，不过经过了一定的压缩，直接存和当前节点`i`邻接的节点编号`j`，例如图：

![img](images/find_the_city_01.png)

其中**节点的部分**就可以表示为：

```shell
[
	[1],			# node 0
	[0, 2, 3],		# node 1
	[1, 3],			# node 2
	[1, 2]			# node 3
]
```

相比于**邻接矩阵**，我们看看**邻接表**的复杂度：（一共有$m$条边，$n$个节点）

- 查询是否存在一节点到另一节点的边：$O(\log{n})$
- 遍历一个节点的下一个相连的节点：$O(n)$
- 遍历整张图：$O(m)$
- 空间复杂度：$O(2m)$

> 1. **查询是否存在一节点到另一节点的边**取的是排序后的**最差复杂度**，其真正的复杂度是和该节点邻接的节点数有关，在有向图中则是**出度**这一概念，即从这个节点出发，通过一条边能到达几个不同节点的数量。
> 2. **遍历一个节点的下一个相连的节点**的复杂度同理。



#### 邻接表建图

此处还是提供边相关的二维矩阵`edges`，`edges[i]==int[]{u, v}`其中`u`，`v`为不同节点：

```c
for (int i=0; i<n; i++) {
    int u = edges[i][0];
    int v = edges[i][1];
    adj[u].insert(v);
    adj[v].insert(u);
}
```



### 图的遍历

我们会存图了，那我们就聊聊图的遍历。